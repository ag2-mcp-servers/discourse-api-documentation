# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:33:14+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity
from fastapi import Header, UploadFile

from models import Asc, Flag, IncludeSubcategories, Order, Order2, Period
from models.AdminBackups import JsonGetResponse, JsonPostRequest, JsonPostResponse
from models.AdminBadges import JsonGetResponse, JsonPostRequest, JsonPostResponse
from models.AdminBadges_id_ import JsonPutRequest, JsonPutResponse
from models.AdminGroups import JsonPostRequest, JsonPostResponse
from models.AdminGroups_id_ import JsonDeleteResponse
from models.AdminUsers_id_ import (
    JsonDeleteRequest,
    JsonDeleteResponse,
    JsonGetResponse,
)
from models.AdminUsers_id_Anonymize import JsonPutResponse
from models.AdminUsers_id_LogOut import JsonPostResponse
from models.AdminUsers_id_Silence import JsonPutRequest, JsonPutResponse
from models.AdminUsers_id_Suspend import JsonPutRequest, JsonPutResponse
from models.AdminUsersList_flag_ import JsonGetResponse
from models.C_id_Show import JsonGetResponse
from models.C_slug__id_ import JsonGetResponse
from models.Categories import JsonGetResponse, JsonPostRequest, JsonPostResponse
from models.Categories_id_ import JsonPutRequest, JsonPutResponse
from models.DirectoryItems import JsonGetResponse
from models.Groups import JsonGetResponse
from models.Groups_id_ import JsonGetResponse, JsonPutRequest, JsonPutResponse
from models.Groups_id_Members import (
    JsonDeleteRequest,
    JsonDeleteResponse,
    JsonGetResponse,
    JsonPutRequest,
    JsonPutResponse,
)
from models.Invites import JsonPostRequest, JsonPostResponse
from models.Latest import JsonGetResponse
from models.Notifications import JsonGetResponse
from models.NotificationsMark_read import JsonPutRequest, JsonPutResponse
from models.PostActions import JsonPostRequest, JsonPostResponse
from models.Posts import JsonGetResponse, JsonPostRequest, JsonPostResponse
from models.Posts_id_ import (
    JsonDeleteRequest,
    JsonGetResponse,
    JsonPutRequest,
    JsonPutResponse,
)
from models.Posts_id_Locked import JsonPutRequest, JsonPutResponse
from models.Posts_id_Replies import JsonGetResponse
from models.Search import JsonGetResponse
from models.SessionForgotPassword import JsonPostRequest, JsonPostResponse
from models.Site import JsonGetResponse
from models.T__id_ import JsonPutRequest, JsonPutResponse
from models.T_id_ import JsonGetResponse
from models.T_id_Change_timestamp import JsonPutRequest, JsonPutResponse
from models.T_id_Invite import JsonPostRequest, JsonPostResponse
from models.T_id_Notifications import JsonPostRequest, JsonPostResponse
from models.T_id_Posts import JsonGetRequest, JsonGetResponse
from models.T_id_Status import JsonPutRequest, JsonPutResponse
from models.T_id_Timer import JsonPostRequest, JsonPostResponse
from models.Tag_name_ import JsonGetResponse
from models.TagGroups import JsonGetResponse, JsonPostRequest, JsonPostResponse
from models.TagGroups_id_ import JsonGetResponse, JsonPutRequest, JsonPutResponse
from models.Tags import JsonGetResponse
from models.Top import JsonGetResponse
from models.TopicsPrivate_messages_sent_username_ import JsonGetResponse
from models.TopicsPrivate_messages_username_ import JsonGetResponse
from models.U_username_ import JsonGetResponse, JsonPutRequest, JsonPutResponse
from models.U_username_Emails import JsonGetResponse
from models.U_username_PreferencesAvatarPick import JsonPutRequest, JsonPutResponse
from models.U_username_PreferencesEmail import JsonPutRequest
from models.U_username_PreferencesUsername import JsonPutRequest
from models.UBy_external_externalId_ import JsonGetResponse
from models.UBy_external_provider__externalId_ import JsonGetResponse
from models.Uploads import JsonPostResponse
from models.UploadsAbort_multipart import JsonPostRequest, JsonPostResponse
from models.UploadsBatch_presign_multipart_parts import (
    JsonPostRequest,
    JsonPostResponse,
)
from models.UploadsComplete_external_upload import JsonPostRequest, JsonPostResponse
from models.UploadsComplete_multipart import JsonPostRequest, JsonPostResponse
from models.UploadsCreate_multipart import JsonPostRequest, JsonPostResponse
from models.UploadsGenerate_presigned_put import JsonPostRequest, JsonPostResponse
from models.User_badges_username_ import JsonGetResponse
from models.UserActions import JsonGetResponse
from models.UserAvatar_username_RefreshGravatar import JsonPostResponse
from models.Users import JsonPostRequest, JsonPostResponse
from models.UsersPassword_reset_token_ import JsonPutRequest

app = MCPProxy(
    description='This page contains the documentation on how to use Discourse through API calls.\n\n> Note: For any endpoints not listed you can follow the\n[reverse engineer the Discourse API](https://meta.discourse.org/t/-/20576)\nguide to figure out how to use an API endpoint.\n\n### Request Content-Type\n\nThe Content-Type for POST and PUT requests can be set to `application/x-www-form-urlencoded`,\n`multipart/form-data`, or `application/json`.\n\n### Endpoint Names and Response Content-Type\n\nMost API endpoints provide the same content as their HTML counterparts. For example\nthe URL `/categories` serves a list of categories, the `/categories.json` API provides the\nsame information in JSON format.\n\nInstead of sending API requests to `/categories.json` you may also send them to `/categories`\nand add an `Accept: application/json` header to the request to get the JSON response.\nSending requests with the `Accept` header is necessary if you want to use URLs\nfor related endpoints returned by the API, such as pagination URLs.\nThese URLs are returned without the `.json` prefix so you need to add the header in\norder to get the correct response format.\n\n### Authentication\n\nSome endpoints do not require any authentication, pretty much anything else will\nrequire you to be authenticated.\n\nTo become authenticated you will need to create an API Key from the admin panel.\n\nOnce you have your API Key you can pass it in along with your API Username\nas an HTTP header like this:\n\n```\ncurl -X GET "http://127.0.0.1:3000/admin/users/list/active.json" \\\n-H "Api-Key: 714552c6148e1617aeab526d0606184b94a80ec048fc09894ff1a72b740c5f19" \\\n-H "Api-Username: system"\n```\n\nand this is how POST requests will look:\n\n```\ncurl -X POST "http://127.0.0.1:3000/categories" \\\n-H "Content-Type: multipart/form-data;" \\\n-H "Api-Key: 714552c6148e1617aeab526d0606184b94a80ec048fc09894ff1a72b740c5f19" \\\n-H "Api-Username: system" \\\n-F "name=89853c20-4409-e91a-a8ea-f6cdff96aaaa" \\\n-F "color=49d9e9" \\\n-F "text_color=f0fcfd"\n```\n\n### Boolean values\n\nIf an endpoint accepts a boolean be sure to specify it as a lowercase\n`true` or `false` value unless noted otherwise.\n',
    license={'name': 'MIT', 'url': 'https://docs.discourse.org/LICENSE.txt'},
    title='Discourse API Documentation',
    version='latest',
    servers=[
        {'url': 'http://discourse.local'},
        {
            'url': 'https://{defaultHost}',
            'variables': {'defaultHost': {'default': 'discourse.example.com'}},
        },
    ],
)


@app.get('/admin/backups.json', tags=['backup_management'])
def get_backups():
    """
    List backups
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/admin/backups.json', tags=['backup_management'])
def create_backup(body: JsonPostRequest = None):
    """
    Create backup
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/admin/backups/{filename}', tags=['backup_management'])
def download_backup(filename: str, token: str = ...):
    """
    Download backup
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/admin/backups/{filename}', tags=['backup_management'])
def send_download_backup_email(filename: str):
    """
    Send download backup email
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/admin/badges.json', tags=['badge_management', 'user_activity_and_badges'])
def admin_list_badges():
    """
    List badges
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/admin/badges.json', tags=['badge_management', 'user_activity_and_badges'])
def create_badge(body: JsonPostRequest = None):
    """
    Create badge
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/admin/badges/{id}.json', tags=['badge_management'])
def delete_badge(id: int):
    """
    Delete badge
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/admin/badges/{id}.json', tags=['badge_management', 'user_activity_and_badges']
)
def update_badge(id: int, body: JsonPutRequest = None):
    """
    Update badge
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/admin/groups.json', tags=['group_management'])
def create_group(body: JsonPostRequest = None):
    """
    Create a group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/admin/groups/{id}.json', tags=['group_management'])
def delete_group(id: int):
    """
    Delete a group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/admin/users/list/{flag}.json', tags=['user_management'])
def admin_list_users(
    flag: Flag,
    order: Optional[Order] = None,
    asc: Optional[Asc] = None,
    page: Optional[int] = None,
    show_emails: Optional[bool] = None,
):
    """
    Get a list of users
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/admin/users/{id}.json', tags=['user_management'])
def delete_user(id: int, body: JsonDeleteRequest = None):
    """
    Delete a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/admin/users/{id}.json', tags=['user_management', 'user_id_lookup'])
def admin_get_user(id: int):
    """
    Get a user by id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/admin/users/{id}/anonymize.json', tags=['user_management'])
def anonymize_user(id: int):
    """
    Anonymize a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/admin/users/{id}/log_out.json', tags=['user_management', 'user_authentication']
)
def log_out_user(id: int):
    """
    Log a user out
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/admin/users/{id}/silence.json', tags=['user_management'])
def silence_user(id: int, body: JsonPutRequest = None):
    """
    Silence a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/admin/users/{id}/suspend.json', tags=['user_management'])
def suspend_user(id: int, body: JsonPutRequest = None):
    """
    Suspend a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/c/{id}/show.json', tags=['category_management'])
def get_category(id: int):
    """
    Show category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/c/{slug}/{id}.json', tags=['topic_management', 'category_management'])
def list_category_topics(slug: str, id: int = ...):
    """
    List topics
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/categories.json', tags=['category_management'])
def list_categories(include_subcategories: Optional[IncludeSubcategories] = None):
    """
    Retrieves a list of categories
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/categories.json', tags=['category_management'])
def create_category(body: JsonPostRequest = None):
    """
    Creates a category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/categories/{id}.json', tags=['category_management'])
def update_category(id: int, body: JsonPutRequest = None):
    """
    Updates a category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/directory_items.json', tags=['user_management'])
def list_users_public(
    period: Period,
    order: Order2 = ...,
    asc: Optional[Asc] = None,
    page: Optional[int] = None,
):
    """
    Get a public list of users
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/groups.json', tags=['group_management', 'user_management'])
def list_groups():
    """
    List groups
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/groups/{id}.json', tags=['group_management'])
def get_group(id: str):
    """
    Get a group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/groups/{id}.json', tags=['group_management'])
def update_group(id: int, body: JsonPutRequest = None):
    """
    Update a group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/groups/{id}/members.json', tags=['group_management', 'user_management'])
def remove_group_members(id: int, body: JsonDeleteRequest = None):
    """
    Remove group members
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/groups/{id}/members.json', tags=['group_management', 'user_management'])
def list_group_members(id: str):
    """
    List group members
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/groups/{id}/members.json', tags=['group_management', 'user_management'])
def add_group_members(id: int, body: JsonPutRequest = None):
    """
    Add group members
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/invites.json', tags=['user_invitation_management'])
def create_invite(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    body: JsonPostRequest = None,
):
    """
    Create an invite
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/latest.json', tags=['topic_management', 'content_search_operations'])
def list_latest_topics(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    order: Optional[str] = None,
    ascending: Optional[str] = None,
):
    """
    Get the latest topics
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/notifications.json', tags=['notification_management', 'user_management'])
def get_notifications():
    """
    Get the notifications that belong to the current user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/notifications/mark-read.json', tags=['notification_management'])
def mark_notifications_as_read(body: JsonPutRequest = None):
    """
    Mark notifications as read
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/post_actions.json', tags=['post_management', 'user_activity_and_badges'])
def perform_post_action(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    body: JsonPostRequest = None,
):
    """
    Like a post and other actions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/posts.json',
    tags=['post_management', 'topic_management', 'content_search_operations'],
)
def list_posts(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    before: Optional[str] = None,
):
    """
    List latest posts across topics
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/posts.json',
    tags=['topic_management', 'post_management', 'private_message_handling'],
)
def create_topic_post_p_m(body: JsonPostRequest = None):
    """
    Creates a new topic, a new post, or a private message
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/posts/{id}.json', tags=['post_management'])
def delete_post(id: int, body: JsonDeleteRequest = None):
    """
    delete a single post
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/posts/{id}.json', tags=['post_management'])
def get_post(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    id: str = ...,
):
    """
    Retrieve a single post
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/posts/{id}.json', tags=['post_management'])
def update_post(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    id: str = ...,
    body: JsonPutRequest = None,
):
    """
    Update a single post
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/posts/{id}/locked.json', tags=['post_management'])
def lock_post(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    id: str = ...,
    body: JsonPutRequest = None,
):
    """
    Lock a post from being edited
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/posts/{id}/replies.json', tags=['post_management'])
def post_replies(id: str):
    """
    List replies to a post
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/search.json', tags=['content_search_operations'])
def search(q: Optional[str] = None, page: Optional[int] = None):
    """
    Search for a term
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/session/forgot_password.json', tags=['user_authentication', 'user_management']
)
def send_password_reset_email(body: JsonPostRequest = None):
    """
    Send password reset email
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/site.json',
    description=""" Can be used to fetch all categories and subcategories """,
    tags=['content_search_operations'],
)
def get_site():
    """
    Get site info
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/t/-/{id}.json', tags=['topic_management'])
def update_topic(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    id: str = ...,
    body: JsonPutRequest = None,
):
    """
    Update a topic
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/t/external_id/{external_id}.json',
    tags=['topic_management', 'content_search_operations'],
)
def get_topic_by_external_id(external_id: str):
    """
    Get topic by external_id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/t/{id}.json', tags=['topic_management'])
def remove_topic(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    id: str = ...,
):
    """
    Remove a topic
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/t/{id}.json', tags=['topic_management', 'content_search_operations'])
def get_topic(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    id: str = ...,
):
    """
    Get a single topic
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/t/{id}/bookmark.json', tags=['topic_management'])
def bookmark_topic(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    id: str = ...,
):
    """
    Bookmark topic
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/t/{id}/change-timestamp.json', tags=['topic_management', 'category_management']
)
def update_topic_timestamp(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    id: str = ...,
    body: JsonPutRequest = None,
):
    """
    Update topic timestamp
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/t/{id}/invite.json', tags=['user_invitation_management', 'topic_management']
)
def invite_to_topic(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    id: str = ...,
    body: JsonPostRequest = None,
):
    """
    Invite to topic
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/t/{id}/notifications.json', tags=['notification_management', 'user_management']
)
def set_notification_level(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    id: str = ...,
    body: JsonPostRequest = None,
):
    """
    Set notification level
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/t/{id}/posts.json', tags=['topic_management', 'post_management'])
def get_specific_posts_from_topic(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    id: str = ...,
    body: JsonGetRequest = None,
):
    """
    Get specific posts from a topic
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/t/{id}/status.json', tags=['topic_management', 'category_management'])
def update_topic_status(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    id: str = ...,
    body: JsonPutRequest = None,
):
    """
    Update the status of a topic
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/t/{id}/timer.json', tags=['topic_management'])
def create_topic_timer(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    id: str = ...,
    body: JsonPostRequest = None,
):
    """
    Create topic timer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/tag/{name}.json', tags=['tag_management'])
def get_tag(name: str):
    """
    Get a specific tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/tag_groups.json', tags=['tag_management'])
def list_tag_groups():
    """
    Get a list of tag groups
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/tag_groups.json', tags=['tag_management'])
def create_tag_group(body: JsonPostRequest = None):
    """
    Creates a tag group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/tag_groups/{id}.json', tags=['tag_management'])
def get_tag_group(id: str):
    """
    Get a single tag group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/tag_groups/{id}.json', tags=['tag_management'])
def update_tag_group(id: str, body: JsonPutRequest = None):
    """
    Update tag group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/tags.json', tags=['tag_management'])
def list_tags():
    """
    Get a list of tags
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/top.json',
    tags=['topic_management', 'content_search_operations', 'category_management'],
)
def list_top_topics(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    period: Optional[str] = None,
):
    """
    Get the top topics filtered by period
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/topics/private-messages-sent/{username}.json',
    tags=['private_message_handling', 'user_management'],
)
def get_user_sent_private_messages(username: str):
    """
    Get a list of private messages sent for a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/topics/private-messages/{username}.json',
    tags=['private_message_handling', 'user_management'],
)
def list_user_private_messages(username: str):
    """
    Get a list of private messages for a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/u/by-external/{external_id}.json', tags=['user_management', 'user_id_lookup']
)
def get_user_external_id(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    external_id: str = ...,
):
    """
    Get a user by external_id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/u/by-external/{provider}/{external_id}.json',
    tags=['user_management', 'user_id_lookup'],
)
def get_user_identiy_provider_external_id(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    provider: str = ...,
    external_id: str = ...,
):
    """
    Get a user by identity provider external ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/u/{username}.json', tags=['user_management', 'user_id_lookup'])
def get_user(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    username: str = ...,
):
    """
    Get a single user by username
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/u/{username}.json', tags=['user_management'])
def update_user(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    username: str = ...,
    body: JsonPutRequest = None,
):
    """
    Update a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/u/{username}/emails.json',
    tags=['user_management', 'user_email_address_management'],
)
def get_user_emails(username: str):
    """
    Get email addresses belonging to a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/u/{username}/preferences/avatar/pick.json',
    tags=['user_management', 'user_avatar_update'],
)
def update_avatar(username: str, body: JsonPutRequest = None):
    """
    Update avatar
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/u/{username}/preferences/email.json',
    tags=['user_management', 'user_email_address_management'],
)
def update_email(username: str, body: JsonPutRequest = None):
    """
    Update email
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/u/{username}/preferences/username.json', tags=['user_management'])
def update_username(username: str, body: JsonPutRequest = None):
    """
    Update username
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/uploads.json', tags=['multipart_file_upload_management'])
def create_upload(file: UploadFile):
    """
    Creates an upload
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/uploads/abort-multipart.json',
    description=""" This endpoint aborts the multipart upload initiated with /create-multipart.
This should be used when cancelling the upload. It does not matter if parts
were already uploaded into the external storage provider.

You must have the correct permissions and CORS settings configured in your
external provider. We support AWS S3 as the default. See:

https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.

An external file store must be set up and `enable_direct_s3_uploads` must
be set to true for this endpoint to function.

 """,
    tags=['multipart_file_upload_management'],
)
def abort_multipart(body: JsonPostRequest = None):
    """
    Abort multipart upload
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/uploads/batch-presign-multipart-parts.json',
    description=""" Multipart uploads are uploaded in chunks or parts to individual presigned
URLs, similar to the one generated by /generate-presigned-put. The part
numbers provided must be between 1 and 10000. The total number of parts
will depend on the chunk size in bytes that you intend to use to upload
each chunk. For example a 12MB file may have 2 5MB chunks and a final
2MB chunk, for part numbers 1, 2, and 3.

This endpoint will return a presigned URL for each part number provided,
which you can then use to send PUT requests for the binary chunk corresponding
to that part. When the part is uploaded, the provider should return an
ETag for the part, and this should be stored along with the part number,
because this is needed to complete the multipart upload.

You must have the correct permissions and CORS settings configured in your
external provider. We support AWS S3 as the default. See:

https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.

An external file store must be set up and `enable_direct_s3_uploads` must
be set to true for this endpoint to function.

 """,
    tags=['multipart_file_upload_management'],
)
def batch_presign_multipart_parts(body: JsonPostRequest = None):
    """
    Generates batches of presigned URLs for multipart parts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/uploads/complete-external-upload.json',
    description=""" Completes an external upload initialized with /get-presigned-put. The
file will be moved from its temporary location in external storage to
a final destination in the S3 bucket. An Upload record will also be
created in the database in most cases.

If a sha1-checksum was provided in the initial request it will also
be compared with the uploaded file in storage to make sure the same
file was uploaded. The file size will be compared for the same reason.

You must have the correct permissions and CORS settings configured in your
external provider. We support AWS S3 as the default. See:

https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.

An external file store must be set up and `enable_direct_s3_uploads` must
be set to true for this endpoint to function.

 """,
    tags=['multipart_file_upload_management'],
)
def complete_external_upload(body: JsonPostRequest = None):
    """
    Completes a direct external upload
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/uploads/complete-multipart.json',
    description=""" Completes the multipart upload in the external store, and copies the
file from its temporary location to its final location in the store.
All of the parts must have been uploaded to the external storage provider.
An Upload record will be completed in most cases once the file is copied
to its final location.

You must have the correct permissions and CORS settings configured in your
external provider. We support AWS S3 as the default. See:

https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.

An external file store must be set up and `enable_direct_s3_uploads` must
be set to true for this endpoint to function.

 """,
    tags=['multipart_file_upload_management'],
)
def complete_multipart(body: JsonPostRequest = None):
    """
    Complete multipart upload
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/uploads/create-multipart.json',
    description=""" Creates a multipart upload in the external storage provider, storing
a temporary reference to the external upload similar to /get-presigned-put.

You must have the correct permissions and CORS settings configured in your
external provider. We support AWS S3 as the default. See:

https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.

An external file store must be set up and `enable_direct_s3_uploads` must
be set to true for this endpoint to function.

 """,
    tags=['multipart_file_upload_management'],
)
def create_multipart_upload(body: JsonPostRequest = None):
    """
    Creates a multipart external upload
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/uploads/generate-presigned-put.json',
    description=""" Direct external uploads bypass the usual method of creating uploads
via the POST /uploads route, and upload directly to an external provider,
which by default is S3. This route begins the process, and will return
a unique identifier for the external upload as well as a presigned URL
which is where the file binary blob should be uploaded to.

Once the upload is complete to the external service, you must call the
POST /complete-external-upload route using the unique identifier returned
by this route, which will create any required Upload record in the Discourse
database and also move file from its temporary location to the final
destination in the external storage service.

You must have the correct permissions and CORS settings configured in your
external provider. We support AWS S3 as the default. See:

https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.

An external file store must be set up and `enable_direct_s3_uploads` must
be set to true for this endpoint to function.

 """,
    tags=['multipart_file_upload_management'],
)
def generate_presigned_put(body: JsonPostRequest = None):
    """
    Initiates a direct external upload
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user-badges/{username}.json',
    tags=['badge_management', 'user_activity_and_badges'],
)
def list_user_badges(username: str):
    """
    List badges for a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/user_actions.json', tags=['user_management', 'user_activity_and_badges'])
def list_user_actions(offset: int, username: str = ..., filter: str = ...):
    """
    Get a list of user actions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/user_avatar/{username}/refresh_gravatar.json',
    tags=['user_management', 'user_avatar_update'],
)
def refresh_gravatar(username: str):
    """
    Refresh gravatar
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/users.json', tags=['user_management'])
def create_user(
    api__key: str = Header(..., alias='Api-Key'),
    api__username: str = Header(..., alias='Api-Username'),
    body: JsonPostRequest = None,
):
    """
    Creates a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/users/password-reset/{token}.json',
    tags=['user_management', 'user_authentication', 'secure_user_password_management'],
)
def change_password(token: str, body: JsonPutRequest = None):
    """
    Change password
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
